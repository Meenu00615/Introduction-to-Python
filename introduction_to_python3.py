# -*- coding: utf-8 -*-
"""Introduction_to_Python3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18R7jc82GOZpGnti0YDm6LzXdfexGg3v6
"""

i='early'

if(i=='early'):
  print('cook')
else:
    print("order")

i='late'

if(i=='late'):
  print('order')
else:
  print("cook")

k=70

if(k>=80):
  print("Good")
if(k>=60):
  print("OK")
else:
  print("Need Improvement")

k=90

if(k>=80):
  print("Good")
if(k>=60):
  print("OK")
else:
  print("Need Improvement")

k=70

if(k>=80):
  print("Good")
elif(k>=60):
  print("OK")
else:
  print("Need Improvement")

#Chgeck if number is grearter than 50 and even for that condition
#Check if number if less than 50 and even for that condition

num=30

"""#The concept of conditon inside a condition  is known as **Nested Conditional Statement**."""

if num > 50:
  if num % 2==0:
    print("Number is greater than 50 and even")
  else:
    print("Number is not and but greater than 50")
else:
  if num %2!=0:
    print("Number is less than 50 and odd")
  else:
    print("Number is not odd but less than 50")

"""#What will vbe the output when we set num=50"""

num=50

if num==50:
    print("Number is equal to 50")
if num > 50:
  if num % 2==0:
    print("Number is greater than 50 and even")

  else:
    print("Number is not and but greater than 50")
else:
  if num %2!=0:
    print("Number is less than 50 and odd")
  else:
    print("Number is not odd but less than 50")

"""#Looping Construct"""

#Repeatitive tasks in fewer lines

print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")
print("Hello, привет")

#But the problem is it's too long and time consumimg

#python only run the loop until *stop[-1]*

#for i in iterable(start:stop:step)
 #     print("Hello world")

for i in range(0, 10):
    print("Meenu Patel, How are you!")

#Every 300 value in itrative times

for i in range(0, 2000, 300):
    print("Hello, привет")

#logic that has to be repeted over and over again

"""1!  = 1
2!  = 2
3!  = 6
4!  = 24
5!  = 120
6!  = 720
7!  = 5040
8!  = 40320
9!  = 362880
10! = 3628800
11! = 39916800
12! = 479001600  """



"""#Factorial of 5"""

fact=5
for i in range(1, 5):
    fact=fact*i
print(fact)

"""#Functions
###Predefined function and used defind function
"""

#Predefined function and used defind function: Can call it any and reused that assined function.

#To ease the use of programming language

#For example

import numpy as np
import pandas as pd
import matplotlib as plt

A1=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
np.sum(A1)

np.min(A1)

np.mean(A1)

"""#User defined function
###: following indented will belong to function

"""

#def funtion_name(input parameter):
# do something
#  return result

#square of 6
def square(a):
    sq =a*a
    return(sq)
square(6)

#C(n,k)=    n!
          #k!(n−k)!

#n number of combination and r to be picked from that
#for example 10, 4

n = 10
r = 6

fact_n = 1
for i in range(1, n+1):
    fact_n=fact_n*i
fact_r=1
for i in range(1, n+1):
    fact_r=fact_r*i
fact_n_r=1
for i in range(1, (n-r)+1):
    fact_n_r=fact_n_r*i
C=fact_n/(fact_r * (fact_n_r))
print("Factorial of the combination  ="+ str (C))

def factorial(value):
    fact=1
    for i in range(1, value+1):
        fact=fact*i
    return fact

n=10
r=6

C=factorial(n)/(factorial(r)*factorial(n-r))
print("factorial:" + str(C))

def fun(n,l=[]):
    for i in range(n):
        l.append(i*i)
    return(l)

fun(2)

i=0
while i < 6:
  print(i)
  i+=2
else:
    print(0)

i=1
while True:
     if i % 9 ==0:
        break
     print(i+4)
     i+=2

"""#descriptives of the dataset"""

data1=pd.read_csv("/content/1. Regression - Module - (Housing Prices).csv")

#name_of_the_dataset.function_name(imput_arguments).

data1.head(5)

data1.tail(5)

data1.describe()

#how to include string/category variable in the code

data1.describe(include='all')

data1.info()

#float are continous variable

#This means For example: 2   Sale Price- 21609 non-null  float64 21613-21609=4 values are not availabe in ROWS

#9 ROWS values are not available

#How to find descriptive statistics for the single variable

data1['Sale Price'].mean()

data1['Sale Price'].std()

data1['Sale Price'].min()

data1['Sale Price'].quantile(.25)

#unique function for the string variable

data1["Condition of the House"].unique()

#Using the Numpy Library for standard deviation

#Library_name.inpuut_name(function_parameteres)

np.std(data1['Sale Price'])

#So, here we were getting the different answer because both npython in-built and numpy formulas are different, and now we want the right answer for the degree of freedom, ddof=1

np.std(data1['Sale Price'],ddof=1)

"""#Plotting and Graphs(Line, Pie and bar Graph)"""

#Help to discover certain patern and information

import matplotlib.pyplot as plt

"""#1-Line Graph"""

#x-axis-plt.plot(data_set_name(variable_name))

#y-axis-plt.plot(data_set_name(variable_name))

data2=pd.read_csv("/content/1. Regression - Module - (Housing Prices).csv")

plt.plot(data2['Sale Price'])

plt.plot(data2['Sale Price'], color='red')
plt.xlabel("Record Number")
plt.ylabel("Sale Price")
plt.title("Graphical Representaion")
plt.show()

# Group the data based on the condition of the house

#groupby function for string and categorical value

plt.plot(data2['Sale Price'],marker='o', markerfacecolor='blue', markersize=5,color='red',linewidth=5,linestyle='dashed')

"""#2-Pie"""

data2.groupby('Condition of the House')['ID'].count()

values=(30, 1701, 14031, 5679, 172)

labels=('Bad', 'Execllent', 'Fair', 'Good', 'Okay')

plt.pie(values,labels = labels)

plt.bar(labels, values, color='blue', linewidth=5, linestyle='dashed')
plt.xlabel('Condition of the House')
plt.ylabel('Count of the House')
plt.title('3rd Graphical representation')

"""#Plotting graph: Scatter, Histograph, and Box Plot`"""

plt.scatter(x=data2['Flat Area (in Sqft)'], y=data2['Sale Price'], color='Blue')
plt.xlabel('Area')
plt.ylabel('Selling Price')
plt.title('Selling Price vs Area')
plt.show()

data2.head(1)

plt.scatter(x=data2['No of Bathrooms'], y=data2['Sale Price'], color='green')
plt.xlabel('No of Bathroom')
plt.ylabel("Selling Price")
plt.title("Sellng Price vs No of Bathroom")

plt.scatter(x=data2['Age of House (in Years)'], y=data2['Sale Price'], color='grey')
plt.xlabel('Age of Hose (in Years)')
plt.ylabel('Selling Price')
plt.title('Selling Price vs Age of the House(in Years)')
plt.show()

#histogram is use to plot frequenc count(or simple count of recors over range of the values a varialble can have)

#divide the data into bins

#It will create 100 equal variable

plt.hist(data2['Age of House (in Years)'], bins=10)
plt.xlabel('Age of House (in Years)')
plt.ylabel('No. of Records')
plt.title('Age wise House Distribution')
plt.show()

plt.boxplot(data2['Age of House (in Years)'])

#data is more skewd or center around high values

"""#pandas.groupby"""

#Import data
#Explore data
#Discriptive statistics of data
#Visualize the data

data2['Sale Price'].mean()



#initializing a new column
data2['condition_sale']=0

for i in data2['Condition of the House'].unique():
    condition_mean = data2.loc[data2['Condition of the House'] == i, 'Sale Price'].mean()
    data2.loc[data2['Condition of the House'] == i, 'condition_sale'] = condition_mean
  #plotting mean sales base data of the condition house

plt.figure(dpi=100)



plt.bar(data2['Condition of the House'].unique(), data2['condition_sale'].unique())
plt.xlabel('Codition of the House')
plt.ylabel('Mean Sales Price')
plt.show()

#syntax of groupby()

#dataframe.grouby[('list of golimn to group by')]["column to be grouped"].how to group()

Zip_condition_sale=data2.groupby(['Condition of the House', 'Zipcode'])['Sale Price'].mean()
Zip_condition_sale

#mean of sale price with respect to condition of the house and zipcode

#format can'nt be changed
##complex aggregation

#pandas.pivot_tabel()

zipcode_condition_sale2=pd.pivot_table(data2, index=["Condition of the House", "Zipcode"], values=["Sale Price"],aggfunc=np.mean)
zipcode_condition_sale2

zipcode_condition_sale2=pd.pivot_table(data2, index=["Zipcode"], columns=["Condition of the House"], values=["Sale Price"],aggfunc=np.mean)
zipcode_condition_sale2
#cleaner representation and comprehensive code

"""#pandas.map()
Plot length from plot area
"""

data2['plot_length']=data2['Flat Area (in Sqft)']**0.5
data2['plot_length'].head()

#total area of the hous

data2['Total Area']=data2['Flat Area (in Sqft)']+data2['Lot Area (in Sqft)']
data2['Total Area'].head()

#for the complex cumbersome operation/taks

#map function is more efficient than brute force

data2['Condition of the House'][data2['Condition of the House']=='Fair']='1'
data2['Condition of the House'][data2['Condition of the House']=='Okay']='0'
data2['Condition of the House'][data2['Condition of the House']=='Bad']='0'
data2['Condition of the House'][data2['Condition of the House']=='Good']='1'
data2['Condition of the House'][data2['Condition of the House']=='Excellent']='3'

data2['Condition of the House'].unique()

data2['Condition of the House']=data2['Condition of the House'].map({'Good':'1',
                                                                    'Excellent':'3',
                                                                    'Bad':'0',
                                                                    'Fair':'1',
                                                                    'Okay':'0'})
data2['Condition of the House'].unique()

#For the Date House was sold-Extracting that column in the new column

#with the brute force afd loop example

#Syntax: for i in range(len(data2['column_name])):

#len-total number of the row in the data column

#range-iterable number from 0 to column name

year=[]
for i in range(len(data2['Date House was Sold'])):
  k=data2['Date House was Sold'][i].split()[-1]
  year.append(k)
data2['year_sold']=year
data2['year_sold'].head()

def year(value):
  return value.split()[-1]

#data2['column to opereate on'].map(modifier_function)
data2['year_sold']=data2['Date House was Sold'].map(year)
data2['year_sold'].head()

#limitaion of the map function is it's perform operation on only single column at one time

#To manipulate transform data using multiple column, we use panda.apply() funntion

#import time
#str='21/01/2017'
#datetime_value=time.strptime(str,date_format)

def fun(x):
  x[0]=5
  return x

g=[10, 11, 12]
print(fun(g), g)

"""#Practice Question"""

3*1**3

tup=(1, 2, 3, 4, 5)
tup[2]=10
print(tup)

counts=Counter()
for i in range(len(reviewa)):
  for word in review[i].split(value):
      counts[word]+=1

not(5 < 10) and not(5 > 15)

L1=[10, 20, 30, 40]
L2=L1
L3=L1.copy()
L4=list(L1)
L1[0]=[50]
print(L1, L2, L3, L4)

L1=list()
L1.append([2, [5, 6], 4])
L1.extend([4, 1, 3])
print(L1[0][1][1]+L1[2])

my_array=np.array([1, 2, 3, 4, 5, 6])
my_array.shape

